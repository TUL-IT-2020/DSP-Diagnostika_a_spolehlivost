<HTML>
<HEAD>
<TITLE></TITLE>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1250"> 
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080">

<A name="#1"></A>
<P align="justify"><BIG>Autonomní testy generované v reálném èase </big><BR>
Tyto druhy testù umoòují vıznamnì uspoøit technické vybavení vìnované vestavìnım diagnostickım prostøedkùm a to tak, 
e danı test se generuje podle pøedem zapsaného algoritmu, v reálném èase, a bìhem testování. 
V testované jednotce je pak místo testu samého uloen pouze algoritmus, podle kterého se danı test generuje. 
Tyto metody generování testù se nìkdy oznaèují jako algoritmické. 
Generování testù se pouívá pøedevším v pøípadech, jestlie má testovaná jednotka pravidelnou strukturu. 
Pouívá se pøedevším pro pamìti, obvody PLA a pro strukturovanì navrené sekvenèní obvody. 
Testy mùeme v reálném èase generovat programem nebo obvodovì. Pomocí programu se generují pøedevším vzorky pro pamìti 
RAM. Tyto vzorky mohou bıt rùzného typu. Vìtšinou se jedná o kombinaci zápisu a ètení ze všech bunìk pamìti 
v rùzném poøadí. Nebo vzorky nazıvané jako putující jednièka, putující nula èi posouvající se diagonála. 
Pro ostatní typy obvodù se dává pøednost jednoduchım generátorùm vestavìnım pøímo do struktury testovaného obvodu. 
V tìchto pøípadech se nejèastìji ke komprimaci odezvy na test pouívá posuvnı registr s lineární zpìtnou vazbou. 
Ještì pøed tím, ne zaènu popisovat strukturu a princip èinnosti registru s lineární zpìtnou vazbou, je  
tøeba zmínit se o kódech a zpùsobu kódování, které se v tìchto registrech a nejen v nich pouívá. 
</P>




<A name="#2"></A>
<P align="justify"><big>Cyklické kódy</big><BR>
Cyklické kódy   jsou lineární kódy, které mají tu vlastnost, e je–li </FONT><B>V</B> = 
(v<SUB>n-1</SUB>, v<SUB>n-2</SUB>,..., v<SUB>0</SUB>) kódovım vektorem, je 
kódovım vektorem i vektor <B>V’</B> = (v<SUB>n-2</SUB>, v<SUB>n-3</SUB>,..., 
v<SUB>0</SUB>, v<SUB>n-1</SUB> ). Zkrácenì hovoøíme 
o tzv. cyklické vlastnosti nebo o podmínce cykliènosti.Øadu vlastností cyklickıch kódù lze nejsnáze 
pochopit pøi reprezentaci tìchto kódù pomocí mnohoèlenù. Proto se v této èásti 
pøidrím tohoto zpùsobu popisu cyklickıch kódù. Existuje jednoznaèné pøiøazení 
mezi kódovımi vektory cyklického kódu (n,k) se souøadnicemi z koneèného tìlesa 
GF(q) a mnohoèleny s koeficienty z GF(q) stupnì nišího ne n. Tìmto mnohoèlenùm 
øíkáme kódové mnohoèleny. Je-li  <B>V</B> = (v<SUB>n-1</SUB>, 
v<SUB>n-2</SUB>,..., v<SUB>0</SUB>) kódovı vektor 
cyklického kódu (n,k), má odpovídající mnohoèlen tvar v(x) = 
v <SUB>n-1</SUB>x<SUP>n-1 </SUP><FONT 
face=Symbol>Å</FONT><SUB>q</SUB>...<FONT face=Symbol>Å</FONT><SUB>q 
</SUB>v<SUB>1</SUB>x<SUP>1</SUP><FONT 
face=Symbol>Å</FONT><SUB>q</SUB>v<SUB>0</SUB>x<SUP>0</SUP>. Kde znak “<FONT 
face=Symbol>Å</FONT><SUB>q</SUB>” znaèí sèítání mod 
q.  
<P align="justify"><big>Tìleso GF(2)</big></P>
<P>U dvojkovıch cyklickıch kódu jsou souøadnice, 
resp. koeficienty v</FONT><SUB>i</SUB> z tìlesa 
GF(2), tj. mohou nabıvat jen hodnot 0 a 1, jejich sèítání se provádí mod 2 a 
jejich souèin je totonı s bìnım algebraickım i logickım souèinem.<BR> 
 Ukáeme si na pøíkladu zpùsob poèítání s prvky 
lineární algebry zbytkovıch tøíd mnohoèlenù nad GF(2). Jde vlastnì o stejnı 
princip sèítání a násobení prvkù jako u koneènıch tìles. Algebra obsahuje 
všechny zbytkové tøídy modulo x</FONT><SUP>n </SUP><FONT 
face=Symbol>Å</FONT>1. Sèítání zbytkovıch tøíd 
mnohoèlenù se provádí stejnì jako v bìné algebøe prostøednictvím sèítání 
koeficientù u stejnıch mocnin x, a na to, e se sèítá podle pravidel platnıch v 
GF(2). Tedy napø. </FONT>{x<SUP>2 </SUP>+x + 1}+ {x<SUP>3 </SUP>+x} = {x<SUP>3</SUP> + 
x<SUP>2</SUP> + 1}. 
Násobení se provádí stejnì jako bìné algebraické násobení mnohoèlenù nad 
tìlesem reálnıch èísel s tím, e pokud by souèin byl stupnì n nebo vyššího, 
provede se ještì operace</FONT> modulo (x<SUP>n </SUP>+1).

<LI>Pøíklad:<BR>
Q(x) = x<sup>2</sup> + x + 1<BR>
P (x) = x <sup>3</sup> + x <sup>2</sup> + 1<BR>
P(x) + Q(x) = x <sup>3</sup> + 2x<sup> 2</sup> + x + 2 = x <sup>3</sup> + x<BR>
P(x) - Q(x) = x <sup>3</sup> - x = x <sup>3</sup> + x<BR>
P(x)* Q(x) = x <sup>5</sup> + x + 1. Je-li n=5, je ještì tøeba provést operaci mod x<sup>5</sup>+1 a vısledek bude P(x)*Q(x)=x <BR>
P(x) /Q(x) = x<BR>
P(x) mod Q(x) = x + 1<BR>

 
<P align="justify"><b>Nerozloítelnı polynom v GF(2)</b><BR>
Polynom P(x) stupnì m je nerozloitelnı, pokud není faktotizovatelnı. To znamená, e
ho nelze dìlit beze zbytku ádnım jinım polynomemem nišího øádu.
Pøíklady nerozloitelnıch polynomù:<BR>
x<sup>4</sup> + x <sup>3</sup> + x <sup>2</sup> + x +1<BR>
x<sup>4</sup> + x<sup>3</sup> + 1<BR>
x<sup>4</sup> + x +1<BR>
x<sup>2</sup> + x + 1<BR>
x + 1<BR>
<P>
Ale pozor, x<sup>2</sup>+1 je rozloitelnı<BR>
x<sup>2</sup> + 1 je dìlitelné x + 1 ......... x <sup>2</sup> + 1 = (x+1) (x+1)<BR>

<A name="#primitiv"></A>
<P align="justify"><b>Primitivní polynom</b><BR>
Polynom stupnì m je primitvní pokud dìlí beze zbytku (1+x<sup>k</sup>) , kde k=2<sup>m</sup>-1<BR>
a nedìlí beze zbytku (1+x<sup>i</sup>), pro všechna i&lt;k<BR><P>
Pro kadé pozitivní k, existuje alepoò jeden primitivní polynom øádu k.<BR>
Urèení primitivních polynomù vyšších øádù není snadné. Bìnì se pouívají tabulky.<BR>
<table align="center" border="1" cellpadding="3" cellspacing="0">
<tr><td>m</td><td>Pøíklad polynomu</td><td>Poèet primitivních<BR>polynomù øádu m</td></tr>
<tr><td>1</td><td>x+1</td><td>1</td></tr>
<tr><td>2</td><td>x<sup>2</sup>+x+1</td><td>1</td></tr>
<tr><td>3</td><td>x<sup>3</sup>+x+1</td><td>2</td></tr>
<tr><td>4</td><td>x<sup>4</sup>+x+1</td><td>2</td></tr>
<tr><td>5</td><td>x<sup>5</sup>+x<sup>2</sup>+1</td><td>6</td></tr>
<tr><td>6</td><td>x<sup>5</sup>+x+1</td><td>6</td></tr>
<tr><td>7</td><td>x<sup>7</sup>+x<sup>3</sup>+1</td><td>18</td></tr>
<tr><td>8</td><td>x<sup>8</sup>+x<sup>4</sup>+x<sup>3</sup>+x<sup>2</sup>+1</td><td>16</td></tr>
<tr><td>9</td><td>x<sup>9</sup>+x<sup>4</sup>+1</td><td>48</td></tr>
<tr><td>..</td><td>...</td><td>...</td></tr>
<tr><td>16</td><td>x<sup>16</sup>+x<sup>12</sup>+x<sup>3</sup>+x+1</td><td>2048</td></tr>
</table>


<P align="justify"><b>Realizace násobení a dìlení v GF(2)</b><BR>
Operace násobení a dìlìní polynomù lze snadno realizovat pomocí zapojení skládajícího
se z øetìzce D klopnıch obvodù, obvodù nonekvivalence  a vhodného propojení zpìtnıch vazeb.

Pøíklad<BR>
Obvod <b>násobící</b> polynomem 1 + x<sup>3</sup> + x<sup>4</sup> + x<sup>5</sup> + x<sup>6</sup>.<BR>
<P align="center">
<IMG src="lsfr2.gif"><BR>1.moné øešení</P>

<P align="center"><IMG src="lsfr3.gif"><BR>2.moné øešení</P>


Pøíklad<BR>
Obvod realizující <b>dìlení</b> polynomem 1 + x + x<SUP>3</sup><BR>
<P align="center"><IMG src="lsfr4.gif"><BR>1.moné øešení</P>
<P align="center"><table><tr><td><IMG src="lsfr5.gif"><BR><BR>2.moné øešení</td><td><IMG src="lsfrtab.gif"></td></tr></table></P>


 

<A name="#3"></A>
<P align="justify"><big>LZPR</big><BR>
Posuvné registry s lineární zpìtnou vazbou, oznaèované té lineární zpìtnovazební posuvné registry (LZPR) se osvìdèily 
jako nejvhodnìjší generátory testovací posloupnosti. Protoe se ve zpìtné vazbì pouívá pouze nonekvivalence, co je 
lineární logická funkce, oznaèuje se tato zpìtná vazba jako lineární. S podobnımi vlastnostmi se mùeme setkat i u 
binárních èítaèù, ale LZPR jsou rychlejší a mají jednodušší strukturu. Pøíklad zapojení LZPR se ètyømi stupni je na obrázku 1.
<P align="center"><IMG src="lsfr.gif"><BR><i>Obr. 1 - LZPR</i></P>

Zpìtné vazby jsou zapojeny podle primitivního polynomu x<sup>4</sup>+x+1. Na zaèátku èinnosti musí bıt do daného registru 
vloen nenulovı obsah, protoe z nulového stavu by se LZPR nikdy nedostal. Maximální délka posloupnosti stavù je 2<sup>n</sup>-1, v tomto pøípadì tedy 2<sup>4</sup>-1=15.
(chybí nulovı stav). Této maximální délky lze dosáhnout pouze je-li LZPR zapojen dle <A href="#primitiv">primitivního polynomu</A>. Tento obvod mùeme pouít jako generátor testu tak,
 e jej zabudujeme do testované jednotky a jeho paralelní vıstupy pøipojíme trvale do míst, která chceme stimulovat. 
Tento zpùsob testování lze pouít prakticky pro všechny typy logickıch obvodù, avšak skuteènì úèinnı je pro kombinaèní 
obvody. 
<P align="center"><IMG src="pri.gif"></P>
Jako pøíznakovı analyzátor se pouívá také LZPR a je synchronizován spoleènımi hodinami s generátorem testù. 
Vısledek testu je na konci provádìní testu srovnán s pøíznakem uloenım v pamìti správnıch pøíznakù. 
V pøípadì neshody signalizuje srovnávaè poruchovı stav (viz obr.2). Tento zpùsob realizace vnitøního testu pouívá napø. 
firma Intel ve svém mikroprocesoru 80386. Délka pouitıch LZPR se pohybuje od 12 do 37. 
Dosaené diagnostické pokrytí udává vırobce lepší ne 98% 
<A name="#4"></A>
<P align="justify"><big>HILDO</big><BR>
Pøi návrhu vestavìnıch diagnostickıch prostøedkù je stále vìtší tlak na sniování nákladù na diagnostiku. 
Z tìchto dùvodù vzniká spojení dvou oddìlenıch diagnostickıch èástí systému do jednoho celku. 
Hlavním rysem metody HILDO je to, e v jediném øetìzci LZPR se skrıvá generátor testu a kompresor odezev zároveò.
Toto zapojení bylo navreno pro testování obvodù VLSI a oznaèení HILDO má vıznam Highly Integrated Logic Design Observer.
<P align="center"><IMG src="image17.gif"><BR><i>Obr. 3 - metoda HILDO</i></P>
<P align="justify">
Registr HILDO je ve své podstatì sériovì paralelní pøíznakovı analyzátor. 
Mimo to, e v kadém taktu vygeneruje jeden krok testu na svıch vıstupech, 
tak také v kadém taktu pøijme na svıch paralelních vstupech jednu odezvu na test. 
Tato odezva na test se nejprve pøiète modulo 2 ke stávajícímu obsahu registru a poté se celı obsah 
posune o jedno místo vpravo. Lineární zpìtnovazební registr tedy neprochází svım obvyklım cyklem, 
protoe pøijaté odezvy do daného diagnostického registru vlastnì vkládají v kadém taktu novı poèáteèní stav. 
<BR>
<b>Hledáním cyklu</b> se rozumí provádìní taktù LZPR a pøipojeného testovaného obvodu   a do chvíle, kdy stav LZPR bude shodnı s nìkterım ze stavù, ve kterém se ji bìhìm hledání cyklu nacházel. Pøi testování kombinaèního obvodu se stavy LZPR neustále periodicky v cyklech opakují. Vezme-li se jako poèáteèní stav LZPR libovolnı stav tvoøící posloupnost tohoto cyklu, potom LZPR vdy po stejném poètu taktù dospìje opìt k tomuto stavu. Poèet tìchto taktù bude shodnı pro všechny tyto stavy tvoøící cykl, brali-li by se jako poèáteèní stav LZPR. 
V ideálním pøípadì lze dosáhnout délky cyklu rovné 2<sup>N</sup>, kde N je délkou LZPR (poètem bitù urèujících stav LZPR).  Délka cyklu je obvykle kratší a závisí na polynomu, podle kterého je LZPR zapojen, a dále na konkrétním propojení LZPR a testovaného obvodu. Zmìnou propojení LZPR a testovaného obvodu pøi zachování polynomu se délka cyklu mìní a neplatí tedy, e dosaení maximální délky cyklu je pouze otázkou volby vhodného polynomu. Stejnıch vısledkù lze dosáhnout pouitím jak primitivních polynomù, tak zcela libovolnì zvolenıch polynomù. Pøipojením testovaného obvodu k LZPR toti vznikají další zpìtné vazby, navíc vedené skrz testovanı obvod, take chování celku LZPR+testovanı obvod nelze dopøedu odhadnout a stanovení délky cyklu není prakticky moné jinak ne experimentem<BR>
Hledání cyklu pøi testování sekvenèního obvodu nemá vıznam, protoe stavy LZPR se kvùli existenci vnitøních stavù testovaného obvodu nebudou opakovat tak, jako je tomu u obvodù kombinaèních.<BR>
Pøíznakem nazveme koncovı stav LZPR po provedení zvoleného poètu taktù po vloení poèáteèního stavu.Postupnou injekcí obou typù poruch na všech vodièích testovaného obvodu, nastavením poèáteèního stavu,provedením zvoleného poètu taktù a zaznamenáním pøíznaku lze získat slovník poruch. Slovníkem poruch se rozumí tabulka dvojic pøíznak - porucha. Jeden pøíznak mùe odpovídat více poruchám.
V takovém pøípadì jsou tyto poruchy danım testem vzájemnì nerozlišitelné. Obzvláš nepøíjemné je pokud se pøíznak nìkteré poruchy shoduje s pøíznakem odpovídajícím bezporuchovému stavu.<BR>
Problemem je, jak zjistit pokrytí testu a jak dosáhnout poadovaného pokrytí.
Moné øešení je simulací chování HILDO a injekcí poruch. Právì za tímto úèelem byl vytvoøen program <a href="hildo.htm">HILDO</A>.
</body> 
</HTML>
